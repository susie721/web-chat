import { extends as _extends } from '../_virtual/use-intl.esm.js';
import IntlError, { IntlErrorCode } from './use-intl.esm.js';
import { defaultOnError } from './use-intl.esm6.js';

var MINUTE = 60;
var HOUR = MINUTE * 60;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = DAY * (365 / 12); // Approximation

var YEAR = DAY * 365;

function getRelativeTimeFormatConfig(seconds) {
  var absValue = Math.abs(seconds);
  var value, unit; // We have to round the resulting values, as `Intl.RelativeTimeFormat`
  // will include fractions like '2.1 hours ago'.

  if (absValue < MINUTE) {
    unit = 'second';
    value = Math.round(seconds);
  } else if (absValue < HOUR) {
    unit = 'minute';
    value = Math.round(seconds / MINUTE);
  } else if (absValue < DAY) {
    unit = 'hour';
    value = Math.round(seconds / HOUR);
  } else if (absValue < WEEK) {
    unit = 'day';
    value = Math.round(seconds / DAY);
  } else if (absValue < MONTH) {
    unit = 'week';
    value = Math.round(seconds / WEEK);
  } else if (absValue < YEAR) {
    unit = 'month';
    value = Math.round(seconds / MONTH);
  } else {
    unit = 'year';
    value = Math.round(seconds / YEAR);
  }

  return {
    value: value,
    unit: unit
  };
}

function createFormatter(_ref) {
  var formats = _ref.formats,
      locale = _ref.locale,
      globalNow = _ref.now,
      _ref$onError = _ref.onError,
      onError = _ref$onError === void 0 ? defaultOnError : _ref$onError,
      timeZone = _ref.timeZone;

  function resolveFormatOrOptions(typeFormats, formatOrOptions) {
    var options;

    if (typeof formatOrOptions === 'string') {
      var formatName = formatOrOptions;
      options = typeFormats == null ? void 0 : typeFormats[formatName];

      if (!options) {
        var error = new IntlError(IntlErrorCode.MISSING_FORMAT, process.env.NODE_ENV !== 'production' ? "Format `" + formatName + "` is not available. You can configure it on the provider or provide custom options." : undefined);
        onError(error);
        throw error;
      }
    } else {
      options = formatOrOptions;
    }

    return options;
  }

  function getFormattedValue(value, formatOrOptions, typeFormats, formatter) {
    var options;

    try {
      options = resolveFormatOrOptions(typeFormats, formatOrOptions);
    } catch (error) {
      return String(value);
    }

    try {
      return formatter(options);
    } catch (error) {
      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));
      return String(value);
    }
  }

  function dateTime(
  /** If a number is supplied, this is interpreted as a UTC timestamp. */
  value,
  /** If a time zone is supplied, the `value` is converted to that time zone.
   * Otherwise the user time zone will be used. */
  formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.dateTime, function (options) {
      var _options;

      if (timeZone && !((_options = options) != null && _options.timeZone)) {
        options = _extends({}, options, {
          timeZone: timeZone
        });
      }

      return new Intl.DateTimeFormat(locale, options).format(value);
    });
  }

  function number(value, formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.number, function (options) {
      return new Intl.NumberFormat(locale, options).format(value);
    });
  }

  function relativeTime(
  /** The date time that needs to be formatted. */
  date,
  /** The reference point in time to which `date` will be formatted in relation to.  */
  now) {
    try {
      if (!now) {
        if (globalNow) {
          now = globalNow;
        } else {
          throw new Error(process.env.NODE_ENV !== 'production' ? "The `now` parameter wasn't provided and there was no global fallback configured on the provider." : undefined);
        }
      }

      var dateDate = date instanceof Date ? date : new Date(date);
      var nowDate = now instanceof Date ? now : new Date(now);
      var seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;

      var _getRelativeTimeForma = getRelativeTimeFormatConfig(seconds),
          unit = _getRelativeTimeForma.unit,
          value = _getRelativeTimeForma.value;

      return new Intl.RelativeTimeFormat(locale, {
        numeric: 'auto'
      }).format(value, unit);
    } catch (error) {
      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));
      return String(date);
    }
  }

  return {
    dateTime: dateTime,
    number: number,
    relativeTime: relativeTime
  };
}

export { createFormatter as default };
//# sourceMappingURL=use-intl.esm3.js.map
